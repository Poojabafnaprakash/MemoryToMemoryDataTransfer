# MemoryToMemoryDataTransfer-

A Design Example: Data Transfer from memory to memory     

Abstract:
   Data-path and controller design is implemented using Hardware Description language - Verilog. We used ModelSim and Icarus tools to simulate and check the results. The controller is designed in such a way that it reads data from 8x8 Memory block and writes to 8x4 Memory block.
   
I. INTRODUCTION
      Data-path and controller is designed to implement the data transfer from 8x8 memory block to 8x4 memory block. The data-path consist of various sequential logic blocks. They are:

> Counter
> 8x8 Memory
> 8x4 Memory
> Flip flop
> Comparator
> Adder
> Subtractor
> Multiplexer

Two representations namely Moore and Counter-decoder representation of controller are possible. We have implemented this design using Counter-Decoder logic where a 5-bit counter is combined with various decoders to generate the control signals, namely, WEA (write enable for Memory A), WEB (write enable for Memory B), IncA (increment the address of Memory A), IncB (increment the address of Memory B) and Reset (used to reset the Counter A, Counter B and the whole system). The Simulation is done using Icarus and ModelSim with the test bench module.

II. COMPONENTS USED
The components used to implement this project are as follows:
A. Counter : The counter is used to generate the addresses of the 8x8 memory and 8x4 memory based on IncA and IncB signal.
B. Memory: Memory is used to store the data inputs provided.
C. Flip Flop : D-flip flop is used to store the previous value. So after a clock cycle, the old input is available.
D. Comparator: Comparator is used to check which value is smaller among the two data inputs.
E. Adder: Adder is used to add the adjacent values of the input.
F. Subtractor: Subtractor is used to subtract the adjacent values of the input.
G. Multiplexer: Multiplexer is used to select the added or subtracted value based on the sign.
H. Controller: controller consists of 5-bit up counter and AND and OR gates to generate the control signals. 

III. PROJECT DESCRIPTION
The block diagram of the data flow from Memory A to Memory B is shown in Figure 1. The implementation starts with the design of data-path and then the controller. Firstly, the sequential logic blocks are gathered to design a proper flow between them. Counter A generates the address from 0 to 7 if reset is low. The 8 bitÿdata packets are written in these addresses of Memory A from 0 to 7 through 
the DataInA [7:0] port. This happens till clock cycle 8. Counter A resets and data read operation happens at clock cycle 9 where the data at address 0 is read.


Figure 1. Complete block diagram of data transfer
At clock cycle 10, the data at address 0 becomes available at DOut1. In the next cycle, this data is transferred in the flip flop and is available at DOut2 and the next data from address 1 is available at DOut1. In this cycle, the data at DOut1 and DOut2 is compared in the comparator and the result is stored in the sign bit. Based on the sign bit generated by the comparator either addition or subtraction is performed. If Sign = 1, then addition of data at A0 and A1 is performed. If Sign = 0, then subtraction of data at A0 and A1 is performed. A multiplexer is used to select adder or subtractor value. The data coming out of adder or subtractor is stored in Memory B whose addresses from 0 to 4 are generated by Counter B. 


Figure 2. Counter-Decoder representation of controller as specified in text book

Controller is designed using 5 bit up-counter and four decoders one for each control signal. The decoder used for generating WEA signal is made up of 8 AND gates as the data is written to memory A for 8 clock cycles. The WEA signal should be maintained high for 8 clock cycles. Up counter counts for 18 clock cycles after which it receives reset signal from the output. The reset signal is given to the Up counter using 5 input AND gate and OR gate. The controller generates IncA and IncB signals to enable Counter A and Counter B respectively. The Counter-decoder representation of controller is shown in Figure 2.

Verilog code is written for individual modulesÿlike counter, memory, D-flip flop, Comparator, Adder, Subtractor and Multiplexer. All modules are then integrated into one single module, that is, the Data-Path module by instantiating each module. Test bench is written to test the data flow where the initial data, clock and reset are given as inputs and the waveform is obtained. The results are compared with the results specified in the text book. The block diagram for the Verilog design is shown in Figure 3. The complete timing diagram as specified in the text book is shown in Figure 4.


Figure 3. Verilog Design diagram as generated in ModelSim

IV. VERIFICATION
Verification is an important step to justify the results obtained. We performed verification in three methods. 

Firstly, we designed the timing diagram while designing the data-path. We compared the timing diagram after we embedded the control unit with the timing diagram before adding the control unit. This result was as expected. 


Fig 4: Timing Diagram with control signals as specified in text book
Secondly, we gave different data inputs to compare the results. To explain with an example, at clock cycle 2 the value of Wea goes high and data packet h00 is written to memory h10. The address h1 is generated at clock cycle 3 after one cycle at which IncA goes high. Similarly, other data packets are also written to memory. The data packet h00 is available at DOUt1 at cock cycle 11 after one cycle at which Wea goes low. The other data packets are also available at DOut1 in subsequent clock cycles. The data packet h00 is available at DOut2 at clock cycle 12 with one clock cycle delay. IncB goes high at clock cycle 13. Memory address b h1 is generated at clock cycle 14 after one clock cycle at which IncB goes high and stays at the same value for two clock cycles. ÿThis can be summarized in a verification table in figure 5. 


Figure 5: Verification Table

Thirdly, we compared our waveform with the waveform provided in the text book. 

The waveform generated is shown in figure 6.


Figure 6: Waveform Generated with control signals.

V. LEARNING
  We learnt how the Hardware Description Language is used to code the sequential logic blocks like counter, memory, D-flip flop, Comparator, Adder, Subtractor and Multiplexer. We also got to learn tools like ModelSim and Icarus Verilog for simulation. We learnt how to use blocking and non-blocking statements in procedural blocks. By debugging the code, we got a good understanding of how verification happens. The integration of the controller and data-path gave us an overall understanding of how a data transfer happens between two memory block.

VI. CONCLUSION
  The data transfer from 8x8 memory to 8x4 memory created a bench mark to program in Verilog. This involved in-depth understanding of each combinatorial logic and how each logic works in the hardware. Trouble-shooting is one of the key aspects of the design process. Verification was achieved by cross checking the timing diagram as specified in the design document. The design approach used was to create the waveforms, write the code and then perform the simulation. This stabilizes the theoretical output and practical output and backtracking is easy if any errors occur. 

ACKNOWLEDGMENT
A special thanks to Dr. Ahmet Bindal (Professor, Computer Engineering Dept, SJSU). His clear explanation and guidance in making our concepts clear was the key to success of the project. Also, our TA Mr. Ramakrishna Melgiri helped us in all the queries we had and it helped us to complete the project in the given timeline.  

REFERENCES
[1] Dr. Ahmet Bindal ? Fundamentals of Computer Architecture and Design, 2016 
[2] Verilog Notes- Dr. Ahmet Bindal


LINKS
[3] http://www.asic-world.com/
[4] https://www.edaplayground.com/
[5] http://stackoverflow.com/









